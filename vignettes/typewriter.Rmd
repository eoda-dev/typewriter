---
title: "typewriter"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{typewriter}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(typewriter)
library(rlang)
```

The goal of typewriter is to add type safety to your R code and it is inspired by [Pydantic](https://docs.pydantic.dev/). Under the hood, it mainly uses base R functions to keep its dependencies as low as possible. It lets you

* add types checks to your function arguments with `check_args()`.
* create typed structures/lists with `base_model()` that can be used, among other things, to validate the types of your R objects like data frames.

To make it adding type safety as fun as possible, a typed structure is just an extended R list where types are defined as _simple functions_ (like `is.integer`) or _type strings_ (like `"integer"`) for the basic R types:

```{r}
my_type = base_model(
  a_number = "integer",
  some_text = "character"
)

(obj <- my_type(a_number = 1L, some_text = "typewriter"))
class(obj)
```

Try to assign a character value to an integer field:

```{r}
try(obj$a_number <- "Hi")
```

Try to create a new object with an invalid type:

```{r}
try(my_type(a_number = 1, some_text = "typewriter"))
```

A type can also be described as a function that takes the value to be validated as its only arguments and returns `TRUE` in case of success:

```{r}
my_type <- base_model(
  a_number = is.integer,
  some_text = is.character
)

(obj <- my_type(a_number = 1:2, some_text = "typewriter"))
try(my_type(a_number = NULL, some_text = "typewriter"))
```

Maybe you just want to allow a single number and make `some_text` optional:

```{r}
my_type <- base_model(
  a_number = function(x) is_integer(x) & length(x) == 1,
  some_text = Optional(is_character)
)

my_type(a_number = 1L)
try(my_type(a_number = 1:2))
```
